# Research Findings: COER Form

**Feature**: [spec.md](spec.md) | **Plan**: [plan.md](plan.md)

## Method

- Evaluated standalone HTML vs. Vite integration for a Form-Based Tool
- Researched browser file I/O APIs for offline save/load from `file://` protocol
- Assessed print-to-PDF patterns via `window.print()` and `@media print`
- Investigated vanilla JS patterns for dynamic bullet lists without frameworks
- Defined the shared JSON project file schema (first tool to formalize it per Constitution VI)

---

## R1: Standalone HTML vs. Vite/React Integration

**Decision**: Standalone HTML file with embedded CSS and JavaScript.

**Rationale**:
- Constitution Form-Based Tools guardrail: "Standalone HTML or lightweight web application. No build tools required unless complexity demands it; prefer zero-config delivery."
- The COER has no visual diagram, no drag-and-drop, no complex state management — it's a form with text inputs and bullet lists. This does not demand a build system.
- A standalone file can be opened by double-clicking on any OS, shared via email, or served from any static host. Zero installation, zero build step.
- The existing Vite/React/TypeScript toolchain in `src/` is purpose-built for the mind-elixir-based Memory Map tool. Coupling the COER into that build would violate Constitution Principle VI (tool independence — each tool independently deployable).
- The `tools/` directory at repo root establishes a clean separation pattern for future standalone tools.

**Alternatives considered**:
| Approach | Rejected Because |
|----------|-----------------|
| Add COER as a React component/route in the existing Vite app | Couples COER to the Memory Map build pipeline; violates tool independence (Principle VI); adds React overhead for a simple form |
| Vite + TypeScript as a separate sub-project for COER | Over-engineered for 9 text inputs and some arrays; adds build complexity without value |
| Standalone HTML | **Selected** — simplest delivery, zero dependencies, aligns with constitution |

---

## R2: File Save/Load Strategy

**Decision**: Use `<a download>` + Blob for saving and `<input type="file">` + FileReader for loading as the **primary** approach. Feature-detect File System Access API as an enhancement for Chromium users only.

**Rationale**:
- `showSaveFilePicker` / `showOpenFilePicker` (File System Access API) requires a **secure context** — it does **not** work on `file://` protocol. Since the COER tool must work when opened directly from the file system, the FSAA path cannot be the primary mechanism.
- The `<a download>` + `<input type="file">` pattern works universally: Chrome, Safari, Firefox, Edge, and from `file://` protocol.
- File System Access API can be offered as an enhancement when detected (e.g., on localhost or HTTPS hosting), providing a better "save to same file" UX for Chromium users.

**Implementation approach**:
- **Save**: Serialize state to JSON string → create `Blob` → create object URL → create hidden `<a download="project.json">` → click it → clean up URL.
- **Load**: Hidden `<input type="file" accept=".json">` → user picks file → `FileReader.readAsText()` → `JSON.parse()` → populate form.
- **Enhancement (if File System Access API available)**: Use `showSaveFilePicker` for "save to same file" after initial save. Store file handle in memory for session.

**Gotchas**:
- `<a download>` always triggers a new download (browser may append `(1)`, `(2)` etc.). Acceptable for MVP.
- `<input type="file">` `accept` attribute is advisory — always validate JSON after read.
- On `file://`, localStorage is shared across all local HTML files in some browsers (Firefox). Do not rely on localStorage; use file save/load as primary persistence.

---

## R3: Print-to-PDF Export

**Decision**: `window.print()` with `@media print` CSS. No third-party PDF library.

**Rationale**:
- `window.print()` works universally, including from `file://`.
- Every modern browser offers "Save as PDF" as a printer destination.
- Zero dependency cost.
- The spec requires a clean printable view with no form controls — achievable entirely with CSS.

**Implementation approach**:
- `@media print` rules hide all `<button>`, `<input>`, `<textarea>`, and `.no-print` elements.
- Print view renders question labels and answer content as static text.
- Bullet lists render as `<ul><li>` with content extracted from the form state.
- Footer with "Generated by the Effectiveness Suite app — visit https://claudio.coach for access" appears only in print view.
- `break-inside: avoid` on question sections to prevent awkward page splits.

**Gotchas**:
- Background colors not printed by default; use `print-color-adjust: exact` if needed for header styling.
- `position: fixed` elements repeat on every page — reset to `static` in print CSS.

---

## R4: Markdown Text Export

**Decision**: Build a markdown string in JavaScript and download as `.md` file via `<a download>`.

**Rationale**:
- The spec requires "Export Text" that downloads a markdown file with all 9 questions and answers.
- String concatenation in JS is trivially simple — no library needed.
- Same `<a download>` + Blob pattern used for save.

**Format template**:
```markdown
# Clarity of End Result (COER)

**Initiative**: {name}
**Last Modified**: {timestamp}

## 1. Choose an important responsibility or project to work on
{initiativeName}

## 2. I want to achieve the following specific result(s)...
- {result1}
- {result2}

... (all 9 questions) ...

---
Generated by the Effectiveness Suite app — visit https://claudio.coach for access
```

---

## R5: Dynamic Bullet List Pattern (Vanilla JS)

**Decision**: Array-of-strings as state, `render()` function projects state to DOM, event delegation on parent container.

**Rationale**:
- Simplest pattern that cleanly separates state from DOM.
- Event delegation avoids memory leaks and listener management complexity.
- State array maps directly to the project file JSON format (e.g., `obstacles: string[]`).

**Gotchas**:
- Must HTML-escape user input before injecting via innerHTML to prevent XSS.
- Re-rendering via innerHTML nukes focus — only re-render on add/remove, not on keystroke. Read input values from DOM into state array on save (not on every change).
- Handle empty list case: show "Add item" prompt, keep container visible.

---

## R6: Shared JSON Project File Schema

**Decision**: Define the `effectivenessToolkit` envelope structure now; the COER is the first tool to formalize it.

**Rationale**:
- Constitution Principle VI requires a shared, versioned JSON file with namespaced sections.
- The spec defines the envelope: `{ "effectivenessToolkit": { "version": "1.0", "lastModified": "...", "initiatives": [...] } }`.
- Each initiative has `id`, `name`, and namespaced tool sections (`coer`, `sob`, `memoryMap`, `tmm`, `impactMap`).
- Sections not yet populated are `null` or absent.

**Schema versioning strategy**:
- Top-level `version` field (e.g., `"1.0"`) identifies the envelope schema version.
- Each tool section has its own `lastModified` but no separate version — the tool's behavior is versioned by the envelope version.
- On load, if `version` is unrecognized, show a warning and offer to proceed or abort (per spec edge case: "unrecognised schema version").
- Unknown fields at any level are preserved on round-trip (forward compatibility).

**Alternatives considered**:
| Approach | Rejected Because |
|----------|-----------------|
| Separate file per tool | Violates Constitution VI (single file is the complete project state) |
| Per-section version numbers | Over-engineered for MVP; envelope version sufficient |
| No versioning | Spec and constitution both require versioned format for migration safety |

---

## R7: Form Architecture (State Management)

**Decision**: Plain JavaScript object as the single source of truth. No reactive framework, no pub-sub, no store.

**Rationale**:
- The COER form has ~10 fields. A plain object (`formState`) holds all values.
- On load: parse JSON → populate `formState` → render form from state.
- On save: read DOM inputs into `formState` → serialize to JSON → download.
- On add/remove list item: mutate `formState` array → re-render that specific list.
- This is the minimum viable architecture for a form with no complex interactions.

**State shape** (mirrors the `coer` section in the project file):
```javascript
let formState = {
  initiativeName: '',
  specificResults: [],
  reason: '',
  corporateContribution: '',
  consequencesAchieving: [],
  consequencesNotAchieving: [],
  startingPoint: '',
  stakeholders: [],
  confidencePercent: '',
  obstacles: []
};
```

---

## Summary

| Research Question | Decision | Risk Level |
|-------------------|----------|------------|
| Standalone HTML vs. Vite | Standalone HTML | Low — proven pattern (TiddlyWiki, etc.) |
| File save/load | `<a download>` + `<input type="file">` primary | Low — universal browser support |
| PDF export | `window.print()` + `@media print` | Low — no dependencies |
| Text export | JS string → Blob → `<a download>` | Low — trivial |
| Dynamic lists | State array + render() + event delegation | Low — standard vanilla pattern |
| Project file schema | `effectivenessToolkit` envelope, first formal definition | Medium — sets precedent for all tools |
| State management | Plain JS object, no framework | Low — appropriate for form complexity |

All NEEDS CLARIFICATION items resolved. No blockers for Phase 1.
